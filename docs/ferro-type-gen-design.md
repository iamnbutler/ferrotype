# ferro-type-gen Design

Design document for the TypeScript generation crate companion to ferro-type.

## Overview

`ferro-type-gen` is a code generation crate that writes TypeScript definition files
from Rust types that implement the `TypeScript` trait from `ferro-type`. It handles:

- File writing with configurable output paths
- Export keyword customization (`export type` vs `type`)
- Single-file vs multi-file output modes
- build.rs integration for compile-time generation
- Future: Auto-registration support (pending ft-m5sn research)

## Prior Art Analysis

| Crate | Type Collection | Export Mechanism | Config Style |
|-------|-----------------|------------------|--------------|
| ts-rs | `#[ts(export)]` attribute | Test-time generation | Env vars |
| specta | `TypeCollection::register::<T>()` | `Typescript::default().export_to()` | Builder pattern |
| typescript-type-def | Generic function `write_definition_file::<W, T>()` | Direct writer | Options struct |

**Design choice**: Use a hybrid approach combining specta's explicit registration with
typescript-type-def's options struct pattern. This gives maximum flexibility without
requiring proc-macro magic for type collection.

## API Design

### Core Types

```rust
/// Configuration for TypeScript generation
pub struct Config {
    /// Output file path (required for file-based generation)
    pub output: Option<PathBuf>,

    /// Export style for generated types
    pub export_style: ExportStyle,

    /// Whether to generate .d.ts (declarations only) vs .ts
    pub declaration_only: bool,

    /// Header comment to prepend (default: "Generated by ferro-type-gen")
    pub header: Option<String>,

    /// Whether to add ESM-style .js extensions to imports
    /// (for multi-file mode)
    pub esm_extensions: bool,
}

/// How to export types in the generated file
pub enum ExportStyle {
    /// No export keyword: `type Foo = ...`
    None,
    /// Named exports: `export type Foo = ...`
    Named,
    /// Export as object: `export { Foo, Bar }`
    Grouped,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            output: None,
            export_style: ExportStyle::Named,
            declaration_only: false,
            header: None,
            esm_extensions: false,
        }
    }
}
```

### Builder Pattern

```rust
impl Config {
    pub fn new() -> Self { Self::default() }

    pub fn output(mut self, path: impl AsRef<Path>) -> Self {
        self.output = Some(path.as_ref().to_owned());
        self
    }

    pub fn export_style(mut self, style: ExportStyle) -> Self {
        self.export_style = style;
        self
    }

    pub fn declaration_only(mut self) -> Self {
        self.declaration_only = true;
        self
    }

    pub fn header(mut self, header: impl Into<String>) -> Self {
        self.header = Some(header.into());
        self
    }

    pub fn esm_extensions(mut self) -> Self {
        self.esm_extensions = true;
        self
    }
}
```

### Generator Struct

```rust
/// TypeScript file generator
pub struct Generator {
    config: Config,
    registry: TypeRegistry,
}

impl Generator {
    /// Create a new generator with the given config
    pub fn new(config: Config) -> Self {
        Self {
            config,
            registry: TypeRegistry::new(),
        }
    }

    /// Register a type for generation
    pub fn register<T: TypeScript>(&mut self) -> &mut Self {
        self.registry.register::<T>();
        self
    }

    /// Register multiple types from a TypeDef directly
    pub fn add(&mut self, typedef: TypeDef) -> &mut Self {
        self.registry.add_typedef(typedef);
        self
    }

    /// Generate TypeScript and return as string
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // Header
        if let Some(ref header) = self.config.header {
            output.push_str("// ");
            output.push_str(header);
            output.push_str("\n\n");
        } else {
            output.push_str("// Generated by ferro-type-gen\n");
            output.push_str("// Do not edit manually\n\n");
        }

        // Types in dependency order
        match self.config.export_style {
            ExportStyle::None => output.push_str(&self.registry.render()),
            ExportStyle::Named => output.push_str(&self.registry.render_exported()),
            ExportStyle::Grouped => {
                // Render without exports, then add grouped export
                output.push_str(&self.registry.render());
                let names: Vec<_> = self.registry.type_names().collect();
                output.push_str(&format!("\nexport {{ {} }};\n", names.join(", ")));
            }
        }

        output
    }

    /// Generate TypeScript to the configured output file
    pub fn write(&self) -> std::io::Result<()> {
        let output_path = self.config.output.as_ref()
            .ok_or_else(|| std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                "No output path configured"
            ))?;

        // Create parent directories
        if let Some(parent) = output_path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        let content = self.generate();
        std::fs::write(output_path, content)
    }

    /// Write only if content has changed (for build.rs efficiency)
    pub fn write_if_changed(&self) -> std::io::Result<bool> {
        let output_path = self.config.output.as_ref()
            .ok_or_else(|| std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                "No output path configured"
            ))?;

        let new_content = self.generate();

        // Check if file exists and has same content
        if output_path.exists() {
            let existing = std::fs::read_to_string(output_path)?;
            if existing == new_content {
                return Ok(false); // No change
            }
        }

        // Create parent directories and write
        if let Some(parent) = output_path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        std::fs::write(output_path, new_content)?;
        Ok(true) // Changed
    }
}
```

### Convenience Functions

```rust
/// Generate TypeScript for a single type
pub fn generate<T: TypeScript>() -> String {
    let mut gen = Generator::new(Config::default());
    gen.register::<T>();
    gen.generate()
}

/// Generate TypeScript for multiple types to a file
pub fn export_to_file<P: AsRef<Path>>(
    path: P,
    registry: &TypeRegistry,
) -> std::io::Result<()> {
    let content = registry.render_exported();
    std::fs::write(path, content)
}
```

## build.rs Integration Pattern

### Basic Usage

```rust
// build.rs
use ferro_type_gen::{Config, Generator};

fn main() {
    let mut gen = Generator::new(
        Config::new()
            .output("../frontend/src/types/api.ts")
            .export_style(ExportStyle::Named)
    );

    // Register all API types
    gen.register::<api::User>()
       .register::<api::Post>()
       .register::<api::Comment>();

    gen.write_if_changed()
        .expect("Failed to write TypeScript definitions");
}
```

### With Cargo Rerun

```rust
// build.rs
fn main() {
    // Only regenerate when source files change
    println!("cargo:rerun-if-changed=src/api/");

    let mut gen = Generator::new(
        Config::new()
            .output(std::env::var("TS_OUTPUT").unwrap_or("types.ts".into()))
    );

    // ... register types ...

    gen.write().expect("TypeScript generation failed");
}
```

### API Type Pattern

For large codebases, define a module that lists all exported types:

```rust
// src/api/mod.rs
mod user;
mod post;
mod comment;

pub use user::*;
pub use post::*;
pub use comment::*;

/// Marker type listing all API types for generation
pub struct ApiTypes;

impl ApiTypes {
    pub fn register_all(gen: &mut ferro_type_gen::Generator) {
        gen.register::<User>()
           .register::<Post>()
           .register::<Comment>()
           .register::<CreateUserRequest>()
           .register::<UpdatePostRequest>();
    }
}
```

```rust
// build.rs
fn main() {
    let mut gen = Generator::new(Config::new().output("types.ts"));
    api::ApiTypes::register_all(&mut gen);
    gen.write().unwrap();
}
```

## Future: Auto-Registration

Once ft-m5sn (inventory vs linkme research) is complete, we can add automatic
type collection. The tentative API:

```rust
// With auto-registration feature enabled
use ferro_type::TypeScript;

#[derive(TypeScript)]
#[ts(export)]  // Marks type for auto-collection
struct User {
    id: String,
    name: String,
}

// build.rs
fn main() {
    let gen = Generator::new(Config::new().output("types.ts"))
        .collect_all();  // Auto-discovers all #[ts(export)] types

    gen.write().unwrap();
}
```

This feature will be gated behind a cargo feature flag due to the additional
dependencies (inventory or linkme) and potential compile-time impact.

## CLI Interface (Optional/Future)

A CLI is lower priority but could be useful for CI/CD:

```bash
# Generate from cargo project
ferro-type-gen --output types.ts --crate myapp

# From specific module
ferro-type-gen --output types.ts --module myapp::api

# Watch mode for development
ferro-type-gen --output types.ts --watch
```

Implementation would use `cargo metadata` to find the crate and its types.
This is complex and may not be worth the effort given build.rs works well.

## Multi-File Mode (Future)

For large projects, generating separate files per module:

```rust
let gen = Generator::new(
    Config::new()
        .output_dir("frontend/src/types/")  // Directory instead of file
        .multi_file(true)
        .esm_extensions(true)
);

// Generates:
// frontend/src/types/user.ts
// frontend/src/types/post.ts
// frontend/src/types/index.ts (re-exports all)
```

This requires tracking which module each type comes from, which the current
TypeDef IR doesn't capture. Would need to extend `TypeDef::Named` with optional
module path or add a separate module tracking mechanism.

## Crate Structure

```
ferro-type-gen/
├── Cargo.toml
├── src/
│   ├── lib.rs           # Public API exports
│   ├── config.rs        # Config, ExportStyle
│   ├── generator.rs     # Generator struct
│   └── render.rs        # Rendering logic (may reuse from ferro-type)
```

### Dependencies

```toml
[dependencies]
ferro-type = { version = "0.1", path = "../ferrotype" }

[dev-dependencies]
tempfile = "3"  # For testing file generation
```

## Open Questions

1. **Should `Generator` own a `TypeRegistry` or accept one?**
   - Current design: Owns one internally
   - Alternative: Accept `&TypeRegistry` in `generate()`
   - Pro of owning: Simpler API, method chaining
   - Pro of accepting: Reuse registry across generators

2. **File extension: `.ts` vs `.d.ts`?**
   - `.d.ts` is declarations only (no runtime code)
   - Type definitions are declarations, so `.d.ts` makes sense
   - But `.ts` works fine and is more common for generated types
   - Decision: Default to `.ts`, use `declaration_only: true` for `.d.ts`

3. **ESM vs CommonJS?**
   - Generated types are just type declarations, no import style needed
   - ESM extensions matter for multi-file imports
   - Decision: Support via `esm_extensions` option

4. **Integration with TypeRegistry render methods?**
   - `TypeRegistry` already has `render()` and `render_exported()`
   - `Generator` could delegate to these or re-implement
   - Decision: Delegate where possible, extend for new features

## Summary

The `ferro-type-gen` crate provides a straightforward API for generating TypeScript
files from Rust types:

- `Config` struct with builder pattern for configuration
- `Generator` struct for type registration and file writing
- `write_if_changed()` for efficient build.rs integration
- Future extensibility for auto-registration and multi-file output

The design prioritizes explicit type registration over magic, build.rs integration
over CLI, and single-file output initially with multi-file as a future extension.
