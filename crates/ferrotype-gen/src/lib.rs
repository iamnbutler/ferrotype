//! TypeScript file generation for ferro-type
//!
//! This crate provides utilities for generating TypeScript definition files
//! from Rust types that implement the `TypeScript` trait.
//!
//! # Example
//!
//! ```ignore
//! use ferro_type::TypeScript;
//! use ferro_type_gen::{Config, Generator, ExportStyle};
//!
//! #[derive(TypeScript)]
//! struct User {
//!     id: String,
//!     name: String,
//! }
//!
//! let mut gen = Generator::new(
//!     Config::new()
//!         .output("types.ts")
//!         .export_style(ExportStyle::Named)
//! );
//!
//! gen.register::<User>();
//! gen.write().expect("Failed to write TypeScript");
//! ```
//!
//! # build.rs Integration
//!
//! ```ignore
//! // build.rs
//! use ferro_type_gen::{Config, Generator};
//!
//! fn main() {
//!     let mut gen = Generator::new(
//!         Config::new().output("../frontend/src/types/api.ts")
//!     );
//!
//!     gen.register::<api::User>()
//!        .register::<api::Post>();
//!
//!     gen.write_if_changed()
//!         .expect("TypeScript generation failed");
//! }
//! ```

use ferro_type::{TypeDef, TypeRegistry, TypeScript};
use std::path::{Path, PathBuf};

/// How to export types in the generated file
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum ExportStyle {
    /// No export keyword: `type Foo = ...`
    None,
    /// Named exports: `export type Foo = ...` (default)
    #[default]
    Named,
    /// Export as grouped object at end: `export { Foo, Bar }`
    Grouped,
}

/// Configuration for TypeScript generation
#[derive(Debug, Clone, Default)]
pub struct Config {
    /// Output file path (required for file-based generation)
    pub output: Option<PathBuf>,

    /// Export style for generated types
    pub export_style: ExportStyle,

    /// Whether to generate .d.ts (declarations only) vs .ts
    pub declaration_only: bool,

    /// Custom header comment to prepend
    pub header: Option<String>,

    /// Whether to add ESM-style .js extensions to imports
    /// (for future multi-file mode)
    pub esm_extensions: bool,
}

impl Config {
    /// Create a new config with defaults
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the output file path
    pub fn output(mut self, path: impl AsRef<Path>) -> Self {
        self.output = Some(path.as_ref().to_owned());
        self
    }

    /// Set the export style
    pub fn export_style(mut self, style: ExportStyle) -> Self {
        self.export_style = style;
        self
    }

    /// Generate .d.ts declaration file instead of .ts
    pub fn declaration_only(mut self) -> Self {
        self.declaration_only = true;
        self
    }

    /// Set a custom header comment
    pub fn header(mut self, header: impl Into<String>) -> Self {
        self.header = Some(header.into());
        self
    }

    /// Enable ESM-style .js extensions in imports (for future multi-file mode)
    pub fn esm_extensions(mut self) -> Self {
        self.esm_extensions = true;
        self
    }
}

/// TypeScript file generator
///
/// Collects types and generates TypeScript definition files.
#[derive(Debug)]
pub struct Generator {
    config: Config,
    registry: TypeRegistry,
}

impl Generator {
    /// Create a new generator with the given config
    pub fn new(config: Config) -> Self {
        Self {
            config,
            registry: TypeRegistry::new(),
        }
    }

    /// Create a new generator with default config
    pub fn with_defaults() -> Self {
        Self::new(Config::default())
    }

    /// Register a type for generation
    ///
    /// The type must implement the `TypeScript` trait (usually via derive).
    /// Returns `&mut Self` for method chaining.
    pub fn register<T: TypeScript>(&mut self) -> &mut Self {
        self.registry.register::<T>();
        self
    }

    /// Add a TypeDef directly to the registry
    ///
    /// Useful when you have a TypeDef from another source.
    pub fn add(&mut self, typedef: TypeDef) -> &mut Self {
        self.registry.add_typedef(typedef);
        self
    }

    /// Get a reference to the internal registry
    pub fn registry(&self) -> &TypeRegistry {
        &self.registry
    }

    /// Get a mutable reference to the internal registry
    pub fn registry_mut(&mut self) -> &mut TypeRegistry {
        &mut self.registry
    }

    /// Generate TypeScript and return as string
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // Header comment
        if let Some(ref header) = self.config.header {
            output.push_str("// ");
            output.push_str(header);
            output.push('\n');
        } else {
            output.push_str("// Generated by ferro-type-gen\n");
            output.push_str("// Do not edit manually\n");
        }
        output.push('\n');

        // Types in dependency order
        match self.config.export_style {
            ExportStyle::None => {
                output.push_str(&self.registry.render());
            }
            ExportStyle::Named => {
                output.push_str(&self.registry.render_exported());
            }
            ExportStyle::Grouped => {
                // Render without exports
                output.push_str(&self.registry.render());
                // Add grouped export at end
                let names: Vec<_> = self.registry.sorted_types().into_iter().collect();
                if !names.is_empty() {
                    output.push_str("\nexport { ");
                    output.push_str(&names.join(", "));
                    output.push_str(" };\n");
                }
            }
        }

        output
    }

    /// Generate TypeScript to the configured output file
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - No output path is configured
    /// - The file cannot be written
    pub fn write(&self) -> std::io::Result<()> {
        let output_path = self
            .config
            .output
            .as_ref()
            .ok_or_else(|| std::io::Error::new(std::io::ErrorKind::InvalidInput, "No output path configured"))?;

        // Create parent directories
        if let Some(parent) = output_path.parent() {
            if !parent.as_os_str().is_empty() {
                std::fs::create_dir_all(parent)?;
            }
        }

        let content = self.generate();
        std::fs::write(output_path, content)
    }

    /// Write only if content has changed
    ///
    /// Returns `Ok(true)` if the file was written, `Ok(false)` if unchanged.
    /// This is useful in build.rs to avoid unnecessary rebuilds.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - No output path is configured
    /// - The file cannot be read or written
    pub fn write_if_changed(&self) -> std::io::Result<bool> {
        let output_path = self
            .config
            .output
            .as_ref()
            .ok_or_else(|| std::io::Error::new(std::io::ErrorKind::InvalidInput, "No output path configured"))?;

        let new_content = self.generate();

        // Check if file exists and has same content
        if output_path.exists() {
            let existing = std::fs::read_to_string(output_path)?;
            if existing == new_content {
                return Ok(false); // No change
            }
        }

        // Create parent directories and write
        if let Some(parent) = output_path.parent() {
            if !parent.as_os_str().is_empty() {
                std::fs::create_dir_all(parent)?;
            }
        }
        std::fs::write(output_path, new_content)?;
        Ok(true) // Changed
    }
}

impl Default for Generator {
    fn default() -> Self {
        Self::with_defaults()
    }
}

// ============================================================================
// CONVENIENCE FUNCTIONS
// ============================================================================

/// Generate TypeScript for a single type
///
/// Returns the TypeScript definition as a string.
pub fn generate<T: TypeScript>() -> String {
    let mut gen = Generator::with_defaults();
    gen.register::<T>();
    gen.generate()
}

/// Export types from a registry to a file
///
/// Convenience function for simple use cases.
pub fn export_to_file<P: AsRef<Path>>(path: P, registry: &TypeRegistry) -> std::io::Result<()> {
    let content = registry.render_exported();

    // Create parent directories
    let path = path.as_ref();
    if let Some(parent) = path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent)?;
        }
    }

    std::fs::write(path, content)
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use ferro_type::{Field, Primitive, TypeDef};

    #[test]
    fn test_config_builder() {
        let config = Config::new()
            .output("types.ts")
            .export_style(ExportStyle::Named)
            .header("Custom header")
            .declaration_only()
            .esm_extensions();

        assert_eq!(config.output, Some(PathBuf::from("types.ts")));
        assert_eq!(config.export_style, ExportStyle::Named);
        assert_eq!(config.header, Some("Custom header".to_string()));
        assert!(config.declaration_only);
        assert!(config.esm_extensions);
    }

    #[test]
    fn test_generator_register() {
        let mut gen = Generator::with_defaults();

        // Register string type (primitive, no named type added)
        gen.register::<String>();

        // Registry should be empty since String doesn't create a Named type
        assert_eq!(gen.registry().len(), 0);
    }

    #[test]
    fn test_generator_add_typedef() {
        let mut gen = Generator::with_defaults();

        let user_type = TypeDef::Named {
            namespace: vec![],
            name: "User".to_string(),
            def: Box::new(TypeDef::Object(vec![
                Field::new("id", TypeDef::Primitive(Primitive::String)),
                Field::new("name", TypeDef::Primitive(Primitive::String)),
            ])),
        };

        gen.add(user_type);

        assert_eq!(gen.registry().len(), 1);
        assert!(gen.registry().get("User").is_some());
    }

    #[test]
    fn test_generate_export_none() {
        let mut gen = Generator::new(Config::new().export_style(ExportStyle::None));

        gen.add(TypeDef::Named {
            namespace: vec![],
            name: "User".to_string(),
            def: Box::new(TypeDef::Primitive(Primitive::String)),
        });

        let output = gen.generate();
        assert!(output.contains("type User = string;"));
        assert!(!output.contains("export type User"));
    }

    #[test]
    fn test_generate_export_named() {
        let mut gen = Generator::new(Config::new().export_style(ExportStyle::Named));

        gen.add(TypeDef::Named {
            namespace: vec![],
            name: "User".to_string(),
            def: Box::new(TypeDef::Primitive(Primitive::String)),
        });

        let output = gen.generate();
        assert!(output.contains("export type User = string;"));
    }

    #[test]
    fn test_generate_export_grouped() {
        let mut gen = Generator::new(Config::new().export_style(ExportStyle::Grouped));

        gen.add(TypeDef::Named {
            namespace: vec![],
            name: "User".to_string(),
            def: Box::new(TypeDef::Primitive(Primitive::String)),
        });
        gen.add(TypeDef::Named {
            namespace: vec![],
            name: "Post".to_string(),
            def: Box::new(TypeDef::Primitive(Primitive::String)),
        });

        let output = gen.generate();
        assert!(output.contains("type User = string;"));
        assert!(output.contains("type Post = string;"));
        assert!(output.contains("export { "));
        assert!(output.contains("User"));
        assert!(output.contains("Post"));
    }

    #[test]
    fn test_generate_custom_header() {
        let gen = Generator::new(Config::new().header("My custom header"));

        let output = gen.generate();
        assert!(output.starts_with("// My custom header\n"));
    }

    #[test]
    fn test_generate_default_header() {
        let gen = Generator::with_defaults();

        let output = gen.generate();
        assert!(output.contains("// Generated by ferro-type-gen"));
        assert!(output.contains("// Do not edit manually"));
    }

    #[test]
    fn test_write_creates_parent_dirs() {
        let temp_dir = tempfile::tempdir().unwrap();
        let output_path = temp_dir.path().join("nested/dir/types.ts");

        let mut gen = Generator::new(Config::new().output(&output_path));
        gen.add(TypeDef::Named {
            namespace: vec![],
            name: "User".to_string(),
            def: Box::new(TypeDef::Primitive(Primitive::String)),
        });

        gen.write().unwrap();

        assert!(output_path.exists());
        let content = std::fs::read_to_string(&output_path).unwrap();
        assert!(content.contains("export type User = string;"));
    }

    #[test]
    fn test_write_if_changed() {
        let temp_dir = tempfile::tempdir().unwrap();
        let output_path = temp_dir.path().join("types.ts");

        let mut gen = Generator::new(Config::new().output(&output_path));
        gen.add(TypeDef::Named {
            namespace: vec![],
            name: "User".to_string(),
            def: Box::new(TypeDef::Primitive(Primitive::String)),
        });

        // First write should return true (changed)
        assert!(gen.write_if_changed().unwrap());

        // Second write should return false (unchanged)
        assert!(!gen.write_if_changed().unwrap());

        // Add another type
        gen.add(TypeDef::Named {
            namespace: vec![],
            name: "Post".to_string(),
            def: Box::new(TypeDef::Primitive(Primitive::String)),
        });

        // Third write should return true (changed)
        assert!(gen.write_if_changed().unwrap());
    }

    #[test]
    fn test_write_no_output_configured() {
        let gen = Generator::with_defaults();
        let result = gen.write();
        assert!(result.is_err());
        assert_eq!(result.unwrap_err().kind(), std::io::ErrorKind::InvalidInput);
    }

    #[test]
    fn test_convenience_generate() {
        // generate() with a primitive type
        let output = generate::<String>();
        // String is primitive, doesn't produce named types
        assert!(output.contains("// Generated by ferro-type-gen"));
    }

    #[test]
    fn test_convenience_export_to_file() {
        let temp_dir = tempfile::tempdir().unwrap();
        let output_path = temp_dir.path().join("types.ts");

        let mut registry = TypeRegistry::new();
        registry.add_typedef(TypeDef::Named {
            namespace: vec![],
            name: "User".to_string(),
            def: Box::new(TypeDef::Primitive(Primitive::String)),
        });

        export_to_file(&output_path, &registry).unwrap();

        let content = std::fs::read_to_string(&output_path).unwrap();
        assert!(content.contains("export type User = string;"));
    }
}
