//! Rust code generation from ferrotype TypeDef
//!
//! This module generates Rust struct and enum definitions from TypeDef,
//! with serde derives for JSON serialization compatibility.

use convert_case::{Case, Casing};
use ferro_type::{Field, Literal, Primitive, TypeDef, TypeParam};

use crate::TsTypeInfo;

/// Generate Rust code from a list of type definitions.
pub fn generate_rust_from_types(types: &[TsTypeInfo]) -> String {
    let mut output = String::new();

    // Add header
    output.push_str("// Generated by ferro-type-import\n");
    output.push_str("// Do not edit manually\n\n");
    output.push_str("use serde::{Deserialize, Serialize};\n\n");

    for type_info in types {
        output.push_str(&generate_type(type_info));
        output.push_str("\n\n");
    }

    output.trim_end().to_string() + "\n"
}

/// Generate Rust code for a single type.
fn generate_type(type_info: &TsTypeInfo) -> String {
    match &type_info.typedef {
        TypeDef::Named { name, def, .. } => generate_named_type(name, def, type_info.is_interface),
        TypeDef::GenericDef {
            name,
            type_params,
            def,
        } => generate_generic_type(name, type_params, def, type_info.is_interface),
        _ => format!("// Unsupported type: {}", type_info.name),
    }
}

/// Generate a named type (struct or type alias).
fn generate_named_type(name: &str, def: &TypeDef, is_interface: bool) -> String {
    match def {
        TypeDef::Object(fields) if is_interface => generate_struct(name, fields, &[]),
        TypeDef::Union(variants) => generate_union_type(name, variants),
        TypeDef::Primitive(p) => generate_type_alias(name, &primitive_to_rust(p)),
        TypeDef::Array(inner) => {
            let inner_type = typedef_to_rust_type(inner);
            generate_type_alias(name, &format!("Vec<{}>", inner_type))
        }
        TypeDef::Record { key, value } => {
            let key_type = typedef_to_rust_type(key);
            let value_type = typedef_to_rust_type(value);
            generate_type_alias(
                name,
                &format!("std::collections::HashMap<{}, {}>", key_type, value_type),
            )
        }
        TypeDef::Ref(ref_name) => generate_type_alias(name, ref_name),
        TypeDef::Tuple(elements) => {
            let tuple_types: Vec<String> = elements.iter().map(typedef_to_rust_type).collect();
            generate_type_alias(name, &format!("({})", tuple_types.join(", ")))
        }
        TypeDef::Literal(lit) => {
            // Literal types become the underlying type in Rust
            let rust_type = match lit {
                Literal::String(_) => "String",
                Literal::Number(_) => "f64",
                Literal::Boolean(_) => "bool",
            };
            generate_type_alias(name, rust_type)
        }
        TypeDef::Intersection(types) => generate_intersection_type(name, types),
        _ => format!("// TODO: Unsupported definition for {}", name),
    }
}

/// Generate a generic type definition.
fn generate_generic_type(
    name: &str,
    type_params: &[TypeParam],
    def: &TypeDef,
    is_interface: bool,
) -> String {
    let params_str = type_params
        .iter()
        .map(|p| {
            let s = p.name.clone();
            // Add trait bounds if we have constraints
            if p.constraint.is_some() {
                // For simplicity, we don't translate TS constraints to Rust bounds
                // In a more complete implementation, we'd analyze the constraint
            }
            s
        })
        .collect::<Vec<_>>()
        .join(", ");

    match def {
        TypeDef::Object(fields) if is_interface => {
            generate_struct(&format!("{}<{}>", name, params_str), fields, type_params)
        }
        _ => {
            let rust_type = typedef_to_rust_type(def);
            format!(
                "pub type {}<{}> = {};",
                name, params_str, rust_type
            )
        }
    }
}

/// Generate a Rust struct from fields.
fn generate_struct(name: &str, fields: &[Field], _type_params: &[TypeParam]) -> String {
    let mut output = String::new();

    // Add derives
    output.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");

    // Check if we need serde rename_all
    let needs_rename = fields.iter().any(|f| {
        let snake = f.name.to_case(Case::Snake);
        snake != f.name
    });

    if needs_rename {
        output.push_str("#[serde(rename_all = \"camelCase\")]\n");
    }

    output.push_str(&format!("pub struct {} {{\n", name));

    for field in fields {
        let rust_name = field.name.to_case(Case::Snake);
        let rust_type = if field.optional {
            format!("Option<{}>", typedef_to_rust_type(&field.ty))
        } else {
            typedef_to_rust_type(&field.ty)
        };

        // Add field attributes
        if field.optional {
            output.push_str("    #[serde(skip_serializing_if = \"Option::is_none\")]\n");
        }

        // Add rename if needed (specific field rename)
        if rust_name != field.name && !needs_rename {
            output.push_str(&format!("    #[serde(rename = \"{}\")]\n", field.name));
        }

        output.push_str(&format!("    pub {}: {},\n", rust_name, rust_type));
    }

    output.push('}');
    output
}

/// Generate a union type.
///
/// For TypeScript unions, we generate either:
/// - A Rust enum (for discriminated unions or simple literal unions)
/// - A type alias to a more complex type
fn generate_union_type(name: &str, variants: &[TypeDef]) -> String {
    // Check if this is a string literal union (common for status types)
    let all_string_literals = variants.iter().all(|v| matches!(v, TypeDef::Literal(Literal::String(_))));

    if all_string_literals {
        return generate_string_enum(name, variants);
    }

    // Check if it's a nullable type (T | null)
    if variants.len() == 2 {
        let non_null: Vec<_> = variants
            .iter()
            .filter(|v| !matches!(v, TypeDef::Primitive(Primitive::Null)))
            .collect();
        if non_null.len() == 1 {
            let inner_type = typedef_to_rust_type(non_null[0]);
            return generate_type_alias(name, &format!("Option<{}>", inner_type));
        }
    }

    // Check for discriminated union pattern
    if let Some(discriminant) = find_discriminant(variants) {
        return generate_discriminated_enum(name, variants, &discriminant);
    }

    // Fallback: generate a tagged enum
    generate_tagged_enum(name, variants)
}

/// Generate a Rust enum from string literals.
fn generate_string_enum(name: &str, variants: &[TypeDef]) -> String {
    let mut output = String::new();

    output.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    output.push_str("#[serde(rename_all = \"camelCase\")]\n");
    output.push_str(&format!("pub enum {} {{\n", name));

    for variant in variants {
        if let TypeDef::Literal(Literal::String(s)) = variant {
            let variant_name = s.to_case(Case::Pascal);
            // Add serde rename if the variant name differs
            if variant_name.to_case(Case::Camel) != *s {
                output.push_str(&format!("    #[serde(rename = \"{}\")]\n", s));
            }
            output.push_str(&format!("    {},\n", variant_name));
        }
    }

    output.push('}');
    output
}

/// Find the discriminant field in a discriminated union.
fn find_discriminant(variants: &[TypeDef]) -> Option<String> {
    // Look for a common field with literal string values
    let first_fields = match &variants.first()? {
        TypeDef::Object(fields) => fields,
        _ => return None,
    };

    for field in first_fields {
        if let TypeDef::Literal(Literal::String(_)) = &field.ty {
            // Check if all variants have this field with literal values
            let all_have_discriminant = variants.iter().all(|v| {
                if let TypeDef::Object(fields) = v {
                    fields.iter().any(|f| {
                        f.name == field.name && matches!(f.ty, TypeDef::Literal(Literal::String(_)))
                    })
                } else {
                    false
                }
            });

            if all_have_discriminant {
                return Some(field.name.clone());
            }
        }
    }

    None
}

/// Generate a discriminated union enum.
fn generate_discriminated_enum(name: &str, variants: &[TypeDef], discriminant: &str) -> String {
    let mut output = String::new();

    output.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    output.push_str(&format!("#[serde(tag = \"{}\")]\n", discriminant));
    output.push_str(&format!("pub enum {} {{\n", name));

    for variant in variants {
        if let TypeDef::Object(fields) = variant {
            // Find the discriminant value
            let disc_value = fields.iter().find_map(|f| {
                if f.name == *discriminant {
                    if let TypeDef::Literal(Literal::String(s)) = &f.ty {
                        return Some(s.clone());
                    }
                }
                None
            });

            if let Some(value) = disc_value {
                let variant_name = value.to_case(Case::Pascal);

                // Get other fields (excluding discriminant)
                let other_fields: Vec<_> = fields
                    .iter()
                    .filter(|f| f.name != *discriminant)
                    .collect();

                output.push_str(&format!("    #[serde(rename = \"{}\")]\n", value));

                if other_fields.is_empty() {
                    output.push_str(&format!("    {},\n", variant_name));
                } else {
                    output.push_str(&format!("    {} {{\n", variant_name));
                    for field in other_fields {
                        let rust_name = field.name.to_case(Case::Snake);
                        let rust_type = if field.optional {
                            format!("Option<{}>", typedef_to_rust_type(&field.ty))
                        } else {
                            typedef_to_rust_type(&field.ty)
                        };
                        if rust_name != field.name {
                            output.push_str(&format!("        #[serde(rename = \"{}\")]\n", field.name));
                        }
                        output.push_str(&format!("        {}: {},\n", rust_name, rust_type));
                    }
                    output.push_str("    },\n");
                }
            }
        }
    }

    output.push('}');
    output
}

/// Generate a tagged enum for non-discriminated unions.
fn generate_tagged_enum(name: &str, variants: &[TypeDef]) -> String {
    let mut output = String::new();

    output.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    output.push_str("#[serde(untagged)]\n");
    output.push_str(&format!("pub enum {} {{\n", name));

    for (i, variant) in variants.iter().enumerate() {
        let variant_name = format!("Variant{}", i + 1);
        let rust_type = typedef_to_rust_type(variant);
        output.push_str(&format!("    {}({}),\n", variant_name, rust_type));
    }

    output.push('}');
    output
}

/// Generate an intersection type.
///
/// Intersection types (A & B) are flattened into a single struct if all
/// components are objects. Otherwise, falls back to serde_json::Value.
fn generate_intersection_type(name: &str, types: &[TypeDef]) -> String {
    // Try to flatten all object types into a single struct
    let mut all_fields: Vec<Field> = Vec::new();

    for ty in types {
        match ty {
            TypeDef::Object(fields) => {
                // Merge fields, later fields win on conflict
                for field in fields {
                    // Remove any existing field with the same name
                    all_fields.retain(|f| f.name != field.name);
                    all_fields.push(field.clone());
                }
            }
            TypeDef::Ref(ref_name) => {
                // For references, we can't resolve at codegen time
                // Generate a comment noting the reference
                return format!(
                    "// TODO: Intersection with {}\npub type {} = serde_json::Value;",
                    ref_name, name
                );
            }
            TypeDef::Named { def, .. } => {
                // Try to extract fields from named type's definition
                if let TypeDef::Object(fields) = def.as_ref() {
                    for field in fields {
                        all_fields.retain(|f| f.name != field.name);
                        all_fields.push(field.clone());
                    }
                } else {
                    return generate_type_alias(name, "serde_json::Value");
                }
            }
            _ => {
                // Non-object types in intersection - fall back
                return generate_type_alias(name, "serde_json::Value");
            }
        }
    }

    if all_fields.is_empty() {
        return generate_type_alias(name, "serde_json::Value");
    }

    generate_struct(name, &all_fields, &[])
}


/// Generate a type alias.
fn generate_type_alias(name: &str, rust_type: &str) -> String {
    format!("pub type {} = {};", name, rust_type)
}

/// Convert TypeDef to a Rust type string.
fn typedef_to_rust_type(def: &TypeDef) -> String {
    match def {
        TypeDef::Primitive(p) => primitive_to_rust(p).to_string(),
        TypeDef::Array(inner) => format!("Vec<{}>", typedef_to_rust_type(inner)),
        TypeDef::Tuple(elements) => {
            let types: Vec<String> = elements.iter().map(typedef_to_rust_type).collect();
            format!("({})", types.join(", "))
        }
        TypeDef::Object(_fields) => {
            // Inline object types become anonymous - use serde_json::Value as fallback
            "serde_json::Value".to_string()
        }
        TypeDef::Union(variants) => {
            // Check for Option pattern (T | null)
            if variants.len() == 2 {
                let non_null: Vec<_> = variants
                    .iter()
                    .filter(|v| !matches!(v, TypeDef::Primitive(Primitive::Null)))
                    .collect();
                if non_null.len() == 1 {
                    return format!("Option<{}>", typedef_to_rust_type(non_null[0]));
                }
            }
            // For other unions, use serde_json::Value
            "serde_json::Value".to_string()
        }
        TypeDef::Intersection(_) => {
            // Intersection types are complex - use serde_json::Value
            "serde_json::Value".to_string()
        }
        TypeDef::Record { key, value } => {
            let key_type = typedef_to_rust_type(key);
            let value_type = typedef_to_rust_type(value);
            format!("std::collections::HashMap<{}, {}>", key_type, value_type)
        }
        TypeDef::Named { name, .. } => name.clone(),
        TypeDef::Ref(name) => name.clone(),
        TypeDef::Literal(lit) => match lit {
            Literal::String(_) => "String".to_string(),
            Literal::Number(_) => "f64".to_string(),
            Literal::Boolean(_) => "bool".to_string(),
        },
        TypeDef::Function { .. } => {
            // Functions become Box<dyn Fn(...) -> ...> but that's complex
            // For data modeling, we'll use a marker type
            "()".to_string()
        }
        TypeDef::Generic { base, args } => {
            let args_str: Vec<String> = args.iter().map(typedef_to_rust_type).collect();
            format!("{}<{}>", base, args_str.join(", "))
        }
        TypeDef::IndexedAccess { .. } => {
            // Indexed access types need type-level computation
            "serde_json::Value".to_string()
        }
        TypeDef::TemplateLiteral { .. } => "String".to_string(),
        TypeDef::GenericDef { name, .. } => name.clone(),
        TypeDef::TypeParamRef(name) => name.clone(),
    }
}

/// Convert a primitive to its Rust equivalent.
fn primitive_to_rust(p: &Primitive) -> &'static str {
    match p {
        Primitive::String => "String",
        Primitive::Number => "f64",
        Primitive::Boolean => "bool",
        Primitive::Null => "()", // Null becomes unit type
        Primitive::Undefined => "()",
        Primitive::Void => "()",
        Primitive::Never => "!",
        Primitive::Any => "serde_json::Value",
        Primitive::Unknown => "serde_json::Value",
        Primitive::BigInt => "i128",
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{convert_module, parse_typescript};

    fn generate(source: &str) -> String {
        let module = parse_typescript(source).unwrap();
        let types = convert_module(&module);
        generate_rust_from_types(&types)
    }

    #[test]
    fn test_generate_simple_struct() {
        let output = generate(r#"
            interface User {
                id: string;
                name: string;
            }
        "#);

        assert!(output.contains("pub struct User"));
        assert!(output.contains("pub id: String"));
        assert!(output.contains("pub name: String"));
    }

    #[test]
    fn test_generate_optional_field() {
        let output = generate(r#"
            interface Config {
                required: string;
                optional?: number;
            }
        "#);

        assert!(output.contains("pub required: String"));
        assert!(output.contains("pub optional: Option<f64>"));
        assert!(output.contains("skip_serializing_if"));
    }

    #[test]
    fn test_generate_camel_case_rename() {
        let output = generate(r#"
            interface User {
                firstName: string;
                lastName: string;
            }
        "#);

        assert!(output.contains("pub first_name: String"));
        assert!(output.contains("rename_all = \"camelCase\""));
    }

    #[test]
    fn test_generate_array_type() {
        let output = generate(r#"
            interface Container {
                items: string[];
            }
        "#);

        assert!(output.contains("pub items: Vec<String>"));
    }

    #[test]
    fn test_generate_type_alias() {
        let output = generate("type UserId = string;");
        assert!(output.contains("pub type UserId = String;"));
    }

    #[test]
    fn test_generate_string_enum() {
        let output = generate(r#"type Status = "active" | "inactive" | "pending";"#);

        assert!(output.contains("pub enum Status"));
        assert!(output.contains("Active"));
        assert!(output.contains("Inactive"));
        assert!(output.contains("Pending"));
    }

    #[test]
    fn test_generate_nullable_type() {
        let output = generate("type MaybeString = string | null;");
        assert!(output.contains("pub type MaybeString = Option<String>;"));
    }

    #[test]
    fn test_generate_discriminated_union() {
        let output = generate(r#"
            type Message =
                | { type: "text"; content: string }
                | { type: "image"; url: string };
        "#);

        assert!(output.contains("pub enum Message"));
        assert!(output.contains("#[serde(tag = \"type\")]"));
        assert!(output.contains("Text"));
        assert!(output.contains("Image"));
    }

    #[test]
    fn test_generate_intersection_type() {
        let output = generate(r#"
            type Combined = { name: string } & { age: number };
        "#);

        assert!(output.contains("pub struct Combined"));
        assert!(output.contains("pub name: String"));
        assert!(output.contains("pub age: f64"));
    }

    #[test]
    fn test_generate_ts_enum() {
        let output = generate(r#"
            enum Status {
                Active,
                Inactive,
                Pending
            }
        "#);

        assert!(output.contains("pub enum Status"));
        assert!(output.contains("Active"));
        assert!(output.contains("Inactive"));
        assert!(output.contains("Pending"));
    }

    #[test]
    fn test_generate_ts_enum_with_string_values() {
        let output = generate(r#"
            enum Direction {
                Up = "UP",
                Down = "DOWN"
            }
        "#);

        assert!(output.contains("pub enum Direction"));
        // The variant names will be "Up" and "Down" (PascalCase)
        // with serde renames to "UP" and "DOWN"
        assert!(output.contains("Up"));
        assert!(output.contains("Down"));
    }
}
