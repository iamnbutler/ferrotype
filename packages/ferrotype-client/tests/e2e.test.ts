/**
 * E2E tests for the Ferrotype RPC client against a real Rust server.
 *
 * These tests require the ferrotype-test-server to be running:
 *   cargo run -p ferrotype-test-server
 *
 * The server listens on http://localhost:3000 by default.
 */

import { describe, it, expect, beforeAll } from "vitest";

// Server configuration
const SERVER_URL = process.env.FERROTYPE_SERVER_URL ?? "http://localhost:3000";

// ============================================================================
// Generated Types (would be generated by ferrotype in production)
// ============================================================================

interface User {
  id: number;
  name: string;
  email: string;
  active: boolean;
}

interface GetUserRequest {
  user_id: number;
}

interface GetUserResponse {
  user: User | null;
}

interface ListUsersRequest {
  page: number;
  per_page: number;
  filter: string | null;
}

interface ListUsersResponse {
  users: User[];
  total: number;
  page: number;
  per_page: number;
}

// ============================================================================
// Generated Client (would be generated by ferrotype in production)
// ============================================================================

class UserServiceClient {
  private readonly baseUrl: string;
  private readonly fetchFn: typeof fetch;

  constructor(baseUrl: string, fetchFn: typeof fetch = fetch) {
    this.baseUrl = baseUrl;
    this.fetchFn = fetchFn;
  }

  async getUser(request: GetUserRequest): Promise<GetUserResponse> {
    const response = await this.fetchFn(
      `${this.baseUrl}/UserService/getUser`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(request),
      }
    );
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response.json();
  }

  async listUsers(request: ListUsersRequest): Promise<ListUsersResponse> {
    const response = await this.fetchFn(
      `${this.baseUrl}/UserService/listUsers`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(request),
      }
    );
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    return response.json();
  }
}

// ============================================================================
// Test Utilities
// ============================================================================

/**
 * Check if the server is running and skip tests if not.
 */
async function isServerRunning(): Promise<boolean> {
  try {
    const response = await fetch(`${SERVER_URL}/health`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: "{}",
    });
    return response.ok;
  } catch {
    return false;
  }
}

// ============================================================================
// E2E Tests
// ============================================================================

describe("E2E: UserService", () => {
  let client: UserServiceClient;
  let serverAvailable = false;

  beforeAll(async () => {
    serverAvailable = await isServerRunning();
    if (serverAvailable) {
      client = new UserServiceClient(SERVER_URL);
    }
  });

  describe("getUser", () => {
    it("returns user when found", async () => {
      if (!serverAvailable) {
        console.log("Skipping: Server not running");
        return;
      }

      const response = await client.getUser({ user_id: 42 });
      expect(response.user).not.toBeNull();
      expect(response.user!.id).toBe(42);
      expect(response.user!.name).toBe("User 42");
      expect(response.user!.email).toBe("user42@example.com");
      expect(response.user!.active).toBe(true);
    });

    it("returns null when user not found", async () => {
      if (!serverAvailable) {
        console.log("Skipping: Server not running");
        return;
      }

      const response = await client.getUser({ user_id: 9999 });
      expect(response.user).toBeNull();
    });

    it("handles user_id 0", async () => {
      if (!serverAvailable) {
        console.log("Skipping: Server not running");
        return;
      }

      const response = await client.getUser({ user_id: 0 });
      expect(response.user).toBeNull();
    });
  });

  describe("listUsers", () => {
    it("returns paginated users", async () => {
      if (!serverAvailable) {
        console.log("Skipping: Server not running");
        return;
      }

      const response = await client.listUsers({
        page: 1,
        per_page: 5,
        filter: null,
      });

      expect(response.users.length).toBe(5);
      expect(response.page).toBe(1);
      expect(response.per_page).toBe(5);
      expect(response.total).toBe(1000);
    });

    it("respects pagination parameters", async () => {
      if (!serverAvailable) {
        console.log("Skipping: Server not running");
        return;
      }

      const response = await client.listUsers({
        page: 2,
        per_page: 3,
        filter: null,
      });

      expect(response.users.length).toBe(3);
      expect(response.page).toBe(2);
      // Second page starts at user 4
      expect(response.users[0].id).toBe(4);
    });

    it("applies active filter", async () => {
      if (!serverAvailable) {
        console.log("Skipping: Server not running");
        return;
      }

      const response = await client.listUsers({
        page: 1,
        per_page: 10,
        filter: "active",
      });

      // All returned users should be active
      for (const user of response.users) {
        expect(user.active).toBe(true);
      }
    });

    it("applies inactive filter", async () => {
      if (!serverAvailable) {
        console.log("Skipping: Server not running");
        return;
      }

      const response = await client.listUsers({
        page: 1,
        per_page: 10,
        filter: "inactive",
      });

      // All returned users should be inactive
      for (const user of response.users) {
        expect(user.active).toBe(false);
      }
    });
  });
});

// ============================================================================
// Generic RPC Tests
// ============================================================================

describe("E2E: Generic RPC", () => {
  let serverAvailable = false;

  beforeAll(async () => {
    serverAvailable = await isServerRunning();
  });

  it("handles arbitrary service/method routing", async () => {
    if (!serverAvailable) {
      console.log("Skipping: Server not running");
      return;
    }

    const response = await fetch(`${SERVER_URL}/TestService/testMethod`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ foo: "bar", num: 42 }),
    });

    expect(response.ok).toBe(true);

    const json = await response.json();
    expect(json.service).toBe("TestService");
    expect(json.method).toBe("testMethod");
    expect(json.request.foo).toBe("bar");
    expect(json.request.num).toBe(42);
  });

  it("health check returns server info", async () => {
    if (!serverAvailable) {
      console.log("Skipping: Server not running");
      return;
    }

    const response = await fetch(`${SERVER_URL}/health`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: "{}",
    });

    expect(response.ok).toBe(true);

    const json = await response.json();
    expect(json.status).toBe("healthy");
    expect(json.server).toBe("ferrotype-test-server");
  });
});
